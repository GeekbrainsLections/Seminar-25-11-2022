# Инструкция по работе с Git

## Что такое Git?
Git - это наиболее популярная реализация распредеённой системы контроля версий. Наиболее полпулярной реализацией 

## Подготовка репозитория
Для создания репозитория в папке предпологаемого репозитория необходимо написать команду *git init*. Для этого в терминале с открытой папкой-репозиторем пишем *git init*

## Создание коммитов

### Добавление файлов к коммиту
Для добавления файлов к коммиту используется команда *git add*. Для того, чтобы добавить файл к новому коммиту необходимо в терминале с открытой папкой-репозиторием написать *git add <имя файла>*.

### Создание коммитов
Для создание коммитов используется команда *git commit*. Для этого в терминале с папкой-репозиторием необходимо написать команду *git commit -m "<сообщение к коммиту>"*. Сообщение к коммиту писать ***ОБЯЗАТЕЛЬНО***. 

## Журнал изменений
Для просмотра истории изменений используется команда *git log*. Для этого в терминале с папкой-репозиторем необходимо набрать *git log*.

## Перемещение между коммитами
Для перемещения между коммитами используется команда *git checkout*. Для этого в терминале с папкой-репозиторием необходимо написать *git checkout <номер коммита>*. Номера коммитов можно посмотреть в истории коммитов, описанной в предыдущем пунткте.

## Ветки в Git

### Просмотр списка веток
Для просмотра списка веток используется команда *git branch*. Для этого в терминале с папкой-репозиторием необходимо написать команду *git branch*

### Переход между ветками
Для перехода между ветками используется команда *git checkout*. Для этого в терминале с папкой-репозиторием необходимо написать *git checkout <название ветки>*.


### Создание новой ветки
Для создания новой ветки используется команда *git branch*. Для этого в терминале с папкой-репозиторием необходимо написать *git branch <название ветки>*.

## Слияние веток и разрешение конфликтов
Слияние веток Git является основным процессом при работе у разработчиков. Бывает так, что разработчики в своих разных ветках изменяют один и тот же файл, а также одно и тоже место.

Git может автоматически объединить файлы, если они были изменены в разных местах и на разных строках.

Но, если Git не справился автоматически, то придется исправлять конфликты вручную.

Для этого рассмотрим несколько конфликтов при слиянии.

ИГНОРИРОВАТЬ КОНФЛИКТ
Если не готовы заниматься решением конфликтов, то можно ввести:

$ git merge --abort
Эта команда попытается откатить состояние до того, что было до запуска слияния.

КОНФЛИКТ, РЕШАЕМЫЙ ПОСЛЕДНИМ ДЕЙСТВИЕМ
Предположим, что пришлось делать слияние из ветки feature в ветку develop. Мы переключаемся в ветку feature и выполняем следующую команду.

$ git merge develop
Auto-merging test.conf
CONFLICT (content): Merge conflict in test.conf
Automatic merge failed; fix conflicts and then commit the result.
Если мы откроем файл на который ссылается ошибка “test.conf”, то можем увидеть следующий текст:

$ cat test.conf
<<<<<<< HEAD
Version5 - Изменение для branch feature

=======
Version4.1 - Ветка branch develop
>>>>>>> develop

Можем посмотреть git log каждой ветки и выбрать последнее по времени изменение в наших ветках.

$ git log --oneline --left-right HEAD...MERGE_HEAD
> f099a6c (develop) New version 4.1
< f054b69 (HEAD -> feature/new-site) New version in feature
< f4cb127 Add text for feature
< c5e28e9 (gitlab/feature/new-site) New file static site
Это список коммитов, которые были включены в слияние, с указанием также ветки разработки, в которой находится каждый коммит.

Смотрим изменения, которые происходили в коммите:



-Version4 - Ветка branch develop
+Version4.1 - Ветка branch develop
Видим последние изменения и меняем файл test.conf по последнему коммиту.

После того, как изменили файл по актуальным изменениям, можно продолжить слияние веток без конфликтов:

$ git merge develop
Already up to date.


## Удаление веток
Чтобы удалить локальную ветку GIT, вы можете выполнить одну из следующих команд:

git branch -d branch_name
git branch -D branch_name

Как вы можете заметить, эти команды, в разных вариациях использования, имеют 2 разных аргумента, d и D.

Параметр -d означает --delete, который удалит локальную ветвь, только в случае, если вы смерджили её с какой-то из веток.

Опция -D обозначает --delete --force, которая удаляет ветку независимо от ее статуса push или merge, так что будьте осторожны при её использовании!

Удаление удалённой ветки GIT
Для того, чтобы удалить ветку, уже опубликованную в удалённом репозитории (например, в Bitbucket, GitHub, GitLab), вы можете использовать следующую команду:

git push <remote_repository_name> --delete <branch_name>

Или же, есть ещё одна опция, которую, возможно, будет немного сложнее запомнить:

git push <remote_repository_name> :<branch_name>

Эти основные параметры также могут быть использованы, если вы хотите удалить "тег".

В большинстве случае использования, в качестве remote_branch_name используется origin.
К примеру, код будет выглядеть так: git push origin --delete tests

В некоторых случаях бывает, что при попытке выполнить запрос на удаление ветки, получаем ошибку fatal: 'origin' does not appear to be a git repository fatal: Could not read from remote repository.
Это значит, что мы вводим неправильное имя удалённой ветки.

Это имя задаётся при добавлении удалённого репозитория к себе в проект. К примеру, выполняя эту команду на добавления удалённого репозитория он будет сохранён под именем origin:

git remote add origin h

Но этот же репозиторий мы можем сохранить под любым другим именем, к примеру, выполнив команду:

git remote add test_project https://github.com/truehero/test.git

Уже сможем обращаться к этому репозиторию по имени test_project.

Потому, чтобы избавиться от этой ошибки, достаточно либо сохранить этот репозиторий под именем origin, либо обращаться к этому репозиторию по его реальному имени.

Если вы получили такую ошибку, но не помните, какое имя вы присваивали этому репозиторию, выполните команду: git remote, которая покажет список актуальных удалённых репозиториев и их имена.

## Удаление веток можно призводить путем прописывания команды 'git branch -d <название ветки, которую нужно удалить>' 


## Введение
Git (произн. «гит») — распределённая система управления версиями файлов. Проект был создан Линусом Торвальдсом для управления разработкой ядра Linux. На сегодняшний день поддерживается Джунио Хамано.

Система спроектирована как набор программ, специально разработанных с учётом их использования в скриптах. Это позволяет удобно создавать специализированные системы контроля версий на базе Git или пользовательские интерфейсы. Например, Cogito является именно таким примером фронтенда к репозиториям Git, а StGit использует Git для управления коллекцией патчей.

Git поддерживает быстрое разделение и слияние версий, включает инструменты для визуализации и навигации по нелинейной истории разработки. Как и Darcs, BitKeeper, Mercurial, SVK, Bazaar и Monotone, Git предоставляет каждому разработчику локальную копию всей истории разработки; изменения копируются из одного репозитория в другой.

Удалённый доступ к репозиториям Git обеспечивается git-daemon, gitosis, SSH или HTTP-сервером. TCP-сервис git-daemon входит в дистрибутив Git и является наряду с SSH наиболее распространённым и надёжным методом доступа. Метод доступа по HTTP, несмотря на ряд ограничений, очень популярен в контролируемых сетях, потому что позволяет использовать существующие конфигурации сетевых фильтров.

### Основы работы с удаленным репозиторием

git clone — создание копии (удаленного) репозитория
Для начала работы с центральным репозиторием, следует создать копию оригинального проекта со всей его историей локально.

Клонирует репозиторий, используя протокол http:

git clone http://user@somehost:port/~user/repository/project.git
Клонирует репозиторий с той же машины в директорию myrepo:

git clone /home/username/project myrepo
Клонирует репозиторий, используя безопасный протокол ssh:

git clone ssh://user@somehost:port/~user/repository
У git имеется и собственный протокол:

git clone git://user@somehost:port/~user/repository/project.git/
Импортирует svn репозиторий, используя протокол http:

git svn clone -s http://repo/location
где -s – понимать стандартные папки SVN (trunk, branches, tags)

git fetch и git pull — забираем изменения из центрального репозитория

Для синхронизации текущей ветки с репозиторием используются команды git fetch и git pull.

git fetch — забирает изменения удаленной ветки из репозитория по умолчания, основной ветки; той, которая была использована при клонировании репозитория. Изменения обновят удаленную ветку (remote tracking branch), после чего надо будет провести слияние с локальной ветку командой git merge.

Получает изменений из определенного репозитория:

git fetch /home/username/project
Возможно также использовать синонимы для адресов, создаваемые командой git remote:

git remote add username-project /home/username/project
git fetch username-project
Естественно, что после оценки изменений, например, командой git diff, надо создать коммит слияния с основной:

git merge username-project/master
Команда git pull сразу забирает изменения и проводит слияние с активной веткой. Забирает из репозитория, для которого были созданы удаленные ветки по умолчанию:

git pull
Забирает изменения и метки из определенного репозитория:

git pull username-project --tags
Как правило, используется сразу команда git pull.

###  git push — вносим изменения в удаленный репозиторий
После проведения работы в экспериментальной ветке, слияния с основной, необходимо обновить удаленный репозиторий (удаленную ветку). Для этого используется команда git push.

Отправляет свои изменения в удаленную ветку, созданную при клонировании по умолчанию:

git push
Отправляет изменения из ветки master в ветку experimental удаленного репозитория:

git push ssh://yourserver.com/~you/proj.git master:experimental
В удаленном репозитории origin удаляет ветку experimental:

git push origin :experimental
Отправляет в удаленную ветку master репозитория origin (синоним репозитория по умолчанию) ветки локальной ветки master:

git push origin master:master
Отправляет метки в удаленную ветку master репозитория origin:

git push origin master --tags
Изменяет указатель для удаленной ветке master репозитория origin (master будет такой же как и develop):

git push origin origin/develop:master
Добавляет ветку test в удаленный репозиторий origin, указывающую на коммит ветки develop:

git push origin origin/develop:refs/heads/test


### Работа с локальным репозиторием
Базовые команды
git init — создание репозитория
Команда git init создает в директории пустой репозиторий в виде директории .git, где и будет в дальнейшем храниться вся информация об истории коммитов, тегах — о ходе разработки проекта:

mkdir project-dir
cd project-dir
git init
git add и git rm — индексация изменений
Следующее, что нужно знать — команда git add. Она позволяет внести в индекс — временное хранилище — изменения, которые затем войдут в коммит.

Индексирует измененный файл, либо оповещение о создании нового:

git add EDITEDFILE
Вносит в индекс все изменения, включая новые файлы:

git add .
Из индекса и дерева проекта одновременно файл можно удалить командой git rm.

Удаляет из индекса и дерева проекта отдельные файлы:

git rm FILE1 FILE2
Хороший пример удаления из документации к git, удаляются сразу все файлы txt из папки:

git rm Documentation/\*.txt
Вносит в индекс все удаленные файлы:

git rm -r --cached .
Сбросить весь индекс или удалить из него изменения определенного файла можно командой git reset:

git reset
Удаляет из индекса конкретный файл:

git reset — EDITEDFILE
Команда git reset используется не только для сбрасывания индекса, поэтому дальше ей будет уделено гораздо больше внимания.
git status — состояние проекта, измененные и не добавленные файлы, индексированные файлы
Команду git status, пожалуй, можно считать самой часто используемой наряду с командами коммита и индексации. Она выводит информацию обо всех изменениях, внесенных в дерево директорий проекта по сравнению с последним коммитом рабочей ветки; отдельно выводятся внесенные в индекс и неиндексированные файлы. Использовать ее крайне просто:

git status
Кроме того, git status указывает на файлы с неразрешенными конфликтами слияния и файлы, игнорируемые git.

git commit — совершение коммита
Коммит — базовое понятие во всех системах контроля версий, поэтому совершаться он должен легко и по возможности быстро. В простейшем случае достаточно после индексации набрать:

git commit
Если индекс не пустой, то на его основе будет совершен коммит, после чего пользователя попросят прокомментировать вносимые изменения вызовом команды edit. Сохраняемся, и вуаля! Коммит готов. Есть несколько ключей, упрощающих работу с git commit.

Совершает коммит, автоматически индексируя изменения в файлах проекта. Новые файлы при этом индексироваться не будут! Удаление же файлов будет учтено:

git commit -a
Комментирует коммит прямо из командной строки вместо текстового редактора:

git commit -m «commit comment»
Вносит в индекс и создаёт коммит на основе изменений единственного файла:

git commit FILENAME
Пример написания хорошего сообщения коммита:

Описывает изменение (до 50 символов)

Более детальное объяснение, если необходимо. Перенос на 72 символе
или около того. В некоторых контекстах первая строка рассматривается
как тема письма, а остальное как тело. Пустая строка, отделяющая сводку
от тела, важна (если вы не опустили тело целиком); если вы оставите их
вместе, инструменты, такие как rebase, могут воспринять это неправильно.

Дальнейшие параграфы идут после пустых строк

 - также можно применять маркеры списков

 - обычно в качестве маркера списка используется дефис или звёздочка
   с одним пробелом перед ним и пустыми строками между пунктами,
   хотя соглашения в этом аспекте могут разниться

Если вы используете систему отслеживания задач, поставьте ссылки на нее:

Resolves: #123
See also: #456, #789
git reset — возврат к определенному коммиту, откат изменений, «жесткий» или «мягкий»
Помимо работы с индексом (см. выше), git reset позволяет сбросить состояние проекта до какого-либо коммита в истории. В git данное действие может быть двух видов: «мягкого»(soft reset) и «жесткого» (hard reset).

«Мягкий» (с ключом --soft) резет оставит нетронутыми ваши индекс и все дерево файлов и директорий проекта, вернется к работе с указанным коммитом. Иными словами, если вы обнаруживаете ошибку в только что совершенном коммите или комментарии к нему, то легко можно исправить ситуацию:

Некорректный коммит
git commit
Переход к работе над уже совершенным коммитом, сохраняя все состояние проекта и проиндексированные файлы
git reset --soft HEAD^
Редактирование файла или файлов
Добавление файлов в индекс
git add .
Возврат к последнему коммиту, будет предложено отредактировать его сообщение
git commit -c ORIG_HEAD
Если сообщение оставить прежним, то достаточно изменить регистр ключа -с
git commit -C ORIG_HEAD
Обратите внимание на обозначение HEAD^, оно означает «обратиться к предку последнего коммита». Подробней описан синтаксис такой относительной адресации будет ниже, в разделе «Хэши, тэги, относительная адресация». Соответственно, HEAD — ссылка на последний коммит. Ссылка ORIG_HEAD после «мягкого» резета указывает на оригинальный коммит.

Естественно, можно вернуться и на большую глубину коммитов,

«Жесткий» резет (ключ --hard) — команда, которую следует использовать с осторожностью. git reset --hard вернет дерево проекта и индекс в состояние, соответствующее указанному коммиту, удалив изменения последующих коммитов:

git add .
git commit -m «destined to death»
git reset --hard HEAD~1 — больше никто и никогда не увидит этот позорный коммит...
git reset --hard HEAD~3 — ...вернее, три последних коммита. Никто. Никогда!
Если команда достигнет точки ветвления, удаления коммита не произойдет.

Для команд слияния или выкачивания последних изменений с удаленного репозитория примеры резета будут приведены в соответствующих разделах.

git revert — отмена изменений, произведенных в прошлом отдельным коммитом
Возможна ситуация, в которой требуется отменить изменения, внесенные отдельным коммитом. git revert создает новый коммит, накладывающий обратные изменения.

Отменяет коммит, помеченный тегом:

git revert config-modify-tag
Отменяет коммит, используя его хэш:

git revert cgsjd2h
Для отмены коммита слияния (коммита у которого несколько родителей), необходимо указать хэш и номер одного из родителей коммита:

git revert cgsjd2h -m 1
Для использования команды необходимо, чтобы состояние проекта не отличалось от состояния, зафиксированного последним коммитом.

git log — разнообразная информация о коммитах в целом
Иногда требуется получить информацию об истории коммитов; коммитах, изменивших отдельный файл; коммитах за определенный отрезок времени и так далее. Для этих целей используется команда git log.

Простейший пример использования, в котором приводится короткая справка по всем коммитам, коснувшимся активной в настоящий момент ветки (о ветках и ветвлении подробно узнать можно ниже, в разделе «Ветвления и слияния»):

git log
Получает подробную информацию о каждом в виде патчей по файлам из коммитов можно, добавив ключ -p (или -u):

git log -p
Статистика изменения файлов, вроде числа измененных файлов, внесенных в них строк, удаленных файлов вызывается ключом --stat:

git log --stat
За информацию по созданиям, переименованиям и правам доступа файлов отвечает ключ --summary:

git log --summary
Чтобы просмотреть историю отдельного файла, достаточно указать в виде параметра его имя (кстати, в моей старой версии git этот способ не срабатывает, обязательно добавлять " — " перед «README»):

git log README
или, если версия git не совсем свежая:

git log — README
Далее приводится только более современный вариант синтаксиса. Возможно указывать время, начиная в определенного момента («weeks», «days», «hours», «s» и так далее):

git log --since=«1 day 2 hours» README
git log --since=«2 hours» README
изменения, касающиеся отдельной папки:

git log --since=«2 hours» dir/
Можно отталкиваться от тегов.

Все коммиты, начиная с тега v1:

git log v1...
Все коммиты, включающие изменения файла README, начиная с тега v1:

git log v1... README
Все коммиты, включающие изменения файла README, начиная с тега v1 и заканчивая тегом v2:

git log v1..v2 README
Интересные возможности по формату вывода команды предоставляет ключ --pretty.

Выводит на каждый из коммитов по строчке, состоящей из хэша (здесь — уникального идентификатора каждого коммита, подробней — дальше):

git log --pretty=oneline
Лаконичная информация о коммитах, приводятся только автор и комментарий:

git log --pretty=short
Более полная информация о коммитах, с именем автора, комментарием, датой создания и внесения коммита:

git log --pretty=full/fuller
В принципе, формат вывода можно определить самостоятельно:

git log --pretty=format:'FORMAT'
Определение формата можно поискать в разделе по git log из Git Community Book или справке. Красивый ASCII-граф коммитов выводится с использованием ключа --graph.

git diff — отличия между деревьями проекта, коммитами и т.д.
Своего рода подмножеством команды git log можно считать команду git diff, определяющую изменения между объектами в проекте - деревьями (файлов и директорий).

Показывает изменения, не внесенные в индекс:

git diff
Изменения, внесенные в индекс:

git diff --cached
Изменения в проекте по сравнению с последним коммитом:

git diff HEAD
Предпоследним коммитом:

git diff HEAD^
Можно сравнивать «головы» веток:

git diff master..experimental
или активную ветку с какой-либо:

git diff experimental
git show — показать изменения, внесенные отдельным коммитом
Посмотреть изменения, внесенные любым коммитом в истории, можно командой git show:

git show COMMIT_TAG
git blame и git annotate — команды, помогающие отслеживать изменения файлов
При работе в команде часто требуется выяснить, кто именно написал конкретный код. Удобно использовать команду git blame, выводящую построчную информацию о последнем коммите, коснувшемся строки, имя автора и хэш коммита:

git blame README
Можно указать и конкретные строки для отображения:

git blame -L 2,+3 README — выведет информацию по трем строкам, начиная со второй.
Аналогично работает команда git annotate, выводящая и строки, и информацию о коммитах, их коснувшихся:

git annotate README
git grep — поиск слов по проекту, состоянию проекта в прошлом
git grep, в целом, просто дублирует функционал знаменитой юниксовой команды. Однако он позволяет слова и их сочетания искать в прошлом проекта, что бывает очень полезно.

Ищет слова tst в проекте:

git grep tst
Подсчитывает число упоминаний tst в проекте:

git grep -с tst
Ищет в старой версии проекта:

git grep tst v1
Команда позволяет использовать логическое И и ИЛИ.

Ищет строки, где упоминаются и первое слово, и второе:

git grep -e 'first' --and -e 'another'
Ищет строки, где встречается хотя бы одно из слов:

git grep --all-match -e 'first' -e 'second'
Ветвление
git branch — создание, перечисление и удаление веток
Работа с ветками — очень легкая процедура в git, все необходимые механизмы сконцентрированы в одной команде.

Просто перечисляет существующие ветки, отметив активную:

git branch
Создаёт новую ветку new-branch:

git branch new-branch
Удаляет ветку, если та была залита (merged) с разрешением возможных конфликтов в текущую:

git branch -d new-branch
Удаляет ветку в любом случае:

git branch -D new-branch
Переименовывает ветку:

git branch -m new-name-branch
Показывывает те ветки, среди предков которых есть определенный коммит:

git branch --contains v1.2
Показывает коммит ответвления ветки new-name-branch от ветки master:

git merge-base master new-name-branch
git checkout — переключение между ветками, извлечение файлов
Команда git checkout позволяет переключаться между последними коммитами (если упрощенно) веток:

checkout some-other-branch
Создаёт ветку, в которую и произойдет переключение:

git checkout -b some-other-new-branch
Если в текущей ветке были какие-то изменения по сравнению с последним коммитом в ветке(HEAD), то команда откажется производить переключение, дабы не потерять произведенную работу. Проигнорировать этот факт позволяет ключ -f:

git checkout -f some-other-branch
В случае, когда изменения надо все же сохранить, следует использовать ключ -m. Тогда команда перед переключением попробует залить изменения в текущую ветку и, после разрешения возможных конфликтов переключиться в новую:

git checkout -m some-other-branch
Вернуть файл (или просто вытащить из прошлого коммита) позволяет команда вида:

git checkout somefile
Возвращает somefile к состоянию последнего коммита:

git checkout somefile
Возвращает somefile к состоянию на два коммита назад по ветке:

git checkout HEAD~2 somefile
git merge — слияние веток, разрешение возможных конфликтов
Слияние веток, в отличие от обычной практики централизованных систем, в git происходит практически каждый день. Естественно, что имеется удобный интерфейс к популярной операции.

Пытается объединить текующую ветку и ветку new-feature:

git merge new-feature
В случае возникновения конфликтов коммита не происходит, а по проблемным файлам расставляются специальные метки а-ля svn; сами же файлы отмечаются в индексе как «не соединенные» (unmerged). До тех пор пока проблемы не будут решены, коммит совершить будет нельзя.

Например, конфликт возник в файле TROUBLE, что можно увидеть в git status.

Произошла неудачная попытка слияния:

git merge experiment
Смотрим на проблемные места:

git status
Разрешаем проблемы:

edit TROUBLE
Индексируем наши изменения, тем самым снимая метки:

git add .
Совершаем коммит слияния:

git commit
Вот и все, ничего сложного. Если в процессе разрешения вы передумали разрешать конфликт, достаточно набрать (это вернёт обе ветки в исходные состояния):

git reset --hard HEAD
Если же коммит слияния был совершен, используем команду:

git reset --hard ORIG_HEAD
git rebase — построение ровной линии коммитов
Предположим, разработчик завел дополнительную ветку для разработки отдельной возможности и совершил в ней несколько коммитов. Одновременно по какой-либо причине в основной ветке также были совершены коммиты: например, в нее были залиты изменения с удаленного сервера, либо сам разработчик совершал в ней коммиты.

В принципе, можно обойтись обычным git merge. Но тогда усложняется сама линия разработки, что бывает нежелательно в слишком больших проектах, где участвует множество разработчиков.

Предположим, имеется две ветки, master и топик, в каждой из которых было совершенно несколько коммитов начиная с момента ветвления. Команда git rebase берет коммиты из ветки topic и накладывает их на последний коммит ветки master.

Вариант, в котором явно указывается, что и куда накладывается:

git-rebase master topic
на master накладывается активная в настоящий момент ветка:

git-rebase master
После использования команды история становится линейной. При возникновении конфликтов при поочередном накладывании коммитов работа команды будет останавливаться, а в проблемные местах файлов появятся соответствующие метки. После редактирования, разрешения конфликтов, файлы следует внести в индекс командой:

git add
и продолжить наложение следующих коммитов командой:

git rebase --continue
Альтернативными выходами будут команды пропустить наложение коммита и перейти к следующему:

git rebase --skip 
и отмена работы команды и всех внесенных изменений:

git rebase --abort 
С ключом -i (--interactive) команда будет работать в интерактивном режиме. Пользователю будет предоставлена возможность определить порядок внесения изменений, автоматически будет вызывать редактор для разрешения конфликтов и так далее.

git cherry-pick — применение к дереву проекта изменений, внесенных отдельным коммитом
Если ведется сложная история разработки, с несколькими длинными ветками разработками, может возникнуть необходимость в применении изменений, внесенных отдельным коммитом одной ветки, к дереву другой (активной в настоящий момент).

Изменения, внесенные указанным коммитом будут применены к дереву, автоматически проиндексированы и станут коммитом в активной ветке:

git cherry-pick BUG_FIX_TAG
Ключ -n показывает, что изменения надо просто применить к дереву проекта без индексации и создания коммита:

git cherry-pick BUG_FIX_TAG -n
git worktree - одновременная работа с несколькими ветками
Git позволяет работать одновременно с несколькими ветками одного репозитория. Для добавления ветки в отдельную директорию необходимо выполнить команду:

git worktree add path/ remote/master
Для просмотра всех директориев с ветками можно воспользоваться командой:

git worktree list
Директорию с веткой можно перести в другое место с помощью команды:

git worktree move old-path/ new-path/
После окончания работы с веткой в директории, её можно удалить командой:

git worktree remove path/ 

## Серверные команды репозитория
Команда создания вспомогательных файлов для dumb-сервера в $GIT_DIR/info и $GIT_OBJECT_DIRECTORY/info каталогах, чтобы помочь клиентам узнать, какие ссылки и пакеты есть на сервере:

git update-server-info
Проверяет сколько объектов будет потеряно и объём освобождаемого места при перепаковке репозитория:

git count-objects
Переупаковывает локальный репозиторий:

git gc



### Прочие команды и необходимые возможности
Хэш — уникальная идентификация объектов
В git для идентификации любых объектов используется уникальный (то есть с огромной вероятностью уникальный) хэш из 40 символов, который определяется хэшируюшей функцией на основе содержимого объекта. Объекты — это все: коммиты, файлы, тэги, деревья. Поскольку хэш уникален для содержимого, например, файла, то и сравнивать такие файлы очень легко — достаточно просто сравнить две строки в сорок символов.

Больше всего нас интересует тот факт, что хэши идентифицируют коммиты. В этом смысле хэш — продвинутый аналог ревизий Subversion. Несколько примеров использования хэшей в качестве способа адресации.

Ищет разницу текущего состояния проекта и коммита за номером… сами видите, каким:

git diff f292ef5d2b2f6312bc45ae49c2dc14588eef8da2
То же самое, но оставляем только шесть первых символов. Git поймет, о каком коммите идет речь, если не существует другого коммита с таким началом хэша:

git diff f292ef5
Иногда хватает и четырех символов:

git diff f292
Читает лог с коммита по коммит:

